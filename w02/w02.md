# 第二周：Python与机器人控制

## 一、Python 容器操作完整指南

### 1. 容器基础操作

#### 1.1 列表(List)操作
列表是有序可变序列，用方括号[]表示，支持动态增删元素。
```python
# 创建列表
my_list = [1, 2, 3]
# 增加元素
my_list.append(4)          # 末尾添加 → [1,2,3,4]
my_list.insert(1, 1.5)     # 在索引1处插入 → [1,1.5,2,3,4]
# 删除元素
my_list.pop()              # 删除末尾元素 → [1,1.5,2,3] (返回4)
my_list.remove(1.5)        # 删除指定值 → [1,2,3]
del my_list[0]             # 删除索引0元素 → [2,3]
# 修改元素
my_list[0] = 0             # [0,3]
# 查询元素
print(my_list[0])          # 输出0
print(3 in my_list)        # 输出True
```

#### 1.2 字典(Dict)操作
字典是键值对集合，用花括号{}表示，键必须是不可变类型。
```python
# 创建字典
my_dict = {'a': 1, 'b': 2}
# 增加元素
my_dict['c'] = 3           # {'a':1, 'b':2, 'c':3}
# 删除元素
del my_dict['b']           # {'a':1, 'c':3}
my_dict.pop('a')           # {'c':3} (返回1)
# 修改元素
my_dict['c'] = 30          # {'c':30}
# 查询元素
print(my_dict.get('c'))    # 输出30
print('c' in my_dict)      # 输出True
```

### 2. 列表高级操作

#### 2.1 切片(Slicing)
切片操作可以从序列中提取子序列，格式为[start:stop:step]。
```python
nums = [0, 1, 2, 3, 4, 5]
print(nums[1:4])       # [1, 2, 3] (包含1，不包含4)
print(nums[::2])       # [0, 2, 4] (步长为2)
print(nums[::-1])      # [5,4,3,2,1,0] (反转列表)
```

#### 2.2 列表推导式
列表推导式提供简洁的列表创建语法，可以包含条件过滤。
```python
# 基本形式
squares = [x2 for x in range(5)]  # [0,1,4,9,16]
# 带条件的推导式
even_squares = [x2 for x in range(10) if x%2==0]  # [0,4,16,36,64]
# 嵌套推导式
matrix = [[1,2,3], [4,5,6], [7,8,9]]
flatten = [num for row in matrix for num in row]  # [1,2,3,4,5,6,7,8,9]
```

#### 2.3 解包(Unpacking)
解包操作可以将容器元素分配给多个变量。
```python
# 基本解包
a, b, c = [1, 2, 3]    # a=1, b=2, c=3
# 星号解包
first, *middle, last = [1, 2, 3, 4, 5]
print(first)   # 1
print(middle)  # [2,3,4]
print(last)    # 5
# 函数参数解包
def sum(a, b):
return a + b
args = [10, 20]
print(sum(*args))  # 30
```

### 3. 字典高级操作

#### 3.1 字典推导式
类似列表推导式，用于快速生成字典。
```python
# 基本形式
square_dict = {x: x2 for x in range(5)}  # {0:0, 1:1, 2:4, 3:9, 4:16}
# 键值互换
inverted_dict = {v:k for k,v in square_dict.items()}
# 带条件的推导式
even_squares = {x:x2 for x in range(10) if x%2==0}
```

#### 3.2 字典合并
将多个字典合并为一个字典的几种方法。
```python
dict1 = {'a':1, 'b':2}
dict2 = {'b':3, 'c':4}
# 方法1：update()
merged = dict1.copy()
merged.update(dict2)  # {'a':1, 'b':3, 'c':4}
# 方法2：解包合并 (Python 3.5+)
merged = {dict1, dict2}
# 方法3：合并运算符 (Python 3.9+)
merged = dict1 dict2
```

#### 3.3 字典解包
将字典的键值对作为关键字参数传递。
```python
def print_info(name, age):
print(f"{name} is {age} years old")
person = {'name': 'Alice', 'age': 25}
print_info(person)  # Alice is 25 years old
```

### 4. 元组操作

#### 4.1 元组特性
元组是有序不可变序列，用圆括号()表示。
```python
# 创建元组
my_tuple = (0, 1, 2, 3, 4)
# 切片操作
print(my_tuple[1:3])  # (1, 2)
# 解包操作
x, y, *rest = (1, 2, 3, 4)
print(x)     # 1
print(rest)  # [3,4]
# 单元素元组
single = (42,)  # 必须有逗号
```

#### 4.2 嵌套元组
元组可以嵌套形成多维结构。
```python
# 2D矩阵
matrix = ((1, 2, 3),
(4, 5, 6),
(7, 8, 9))
print(matrix[1][2])  # 6 (第二行第三列)
# 元组解包嵌套
name, (year, month, day) = ('Alice', (1990, 5, 15))
```

#### 4.3 元组与列表转换
元组和列表可以相互转换。
```python
# 列表转元组
list_to_tuple = tuple([1, 2, 3])  # (1,2,3)
# 元组转列表
tuple_to_list = list((1, 2, 3))   # [1,2,3]
# 字符串转元组
chars = tuple('hello')  # ('h','e','l','l','o')
```

## 二、机器人控制Python代码

### 1.动作控制
```python
import hiwonder.ActionGroupControl as AGC

import hiwonder.ros_robot_controller_sdk as rrc
from hiwonder.Controller import Controller

AGC.runActionGroup('go_forward_one_step', times=2, with_stand=True)                         
# 第二个参数为运行动作次数，默认1, 当为0时表示循环运行， 第三个参数表示最后是否以立正姿态收步

threading.Thread(target=AGC.runActionGroup, args=('go_forward', 0, True)).start()  
# 运行动作函数是阻塞式的，如果要循环运行一段时间后停止，请用线程来开启
time.sleep(3)
AGC.stopActionGroup()  # 前进3秒后停止

AGC.runActionGroup('back_one_step') #向后
AGC.runActionGroup('left_move') #向左
AGC.runActionGroup('right_move') #向右

board = rrc.Board()
ctl = Controller(board)

ctl.set_pwm_servo_pulse(1, 1700, 500) # 上下转头
ctl.set_pwm_servo_pulse(2, 1400, 500) # 左右转头

# 三个参数：
## servo_id: 要驱动的舵机id(the servo id needed to be driven)
## pulse: 舵机目标位置(servo target position)
## use_time: 转动需要的时间(the time needed to rotate)
```

### 2.远程控制
```python
from flask import Flask, jsonify, request
import hiwonder.ActionGroupControl as AGC
import hiwonder.ros_robot_controller_sdk as rrc
from hiwonder.Controller import Controller

# 初始化Flask应用
app = Flask(__name__)
board = rrc.Board()
ctl = Controller(board)


# 创建一个API端点来执行动作
# 可以通过访问 http://<树莓派IP>:5000/run_action/stand 来让机器人站立
@app.route('/run_action/<string:action_name>', methods=['GET'])
def run_robot_action(action_name):
    try:
        print(f"接收到指令，执行动作: {action_name}")
        # 直接调用您SDK中的函数
        # 注意：这里的路径需要是机器人的实际路径，如果SDK默认值正确则无需修改
        AGC.runAction(action_name)
        return jsonify({"status": "success", "action": action_name})
    except Exception as e:
        print(f"执行动作失败: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500


@app.route('/turn_head', methods=['POST'])
def turn_head():
    req_data = request.get_json()
    servo_id = req_data.get('servo_id')
    pulse = req_data.get('pulse')
    ctl.set_pwm_servo_pulse(servo_id, pulse, 500)
    return jsonify({"status": "success", "servo_id": servo_id, "pulse": pulse})


if __name__ == '__main__':
    # 监听所有网络接口，这样局域网内的设备才能访问
    app.run(host='0.0.0.0', port=5000)
```

### 3.线程控制
```python
#基本线程创建
import hiwonder.ActionGroupControl as AGC
import hiwonder.ros_robot_controller_sdk as rrc
from hiwonder.Controller import Controller
import threading
import time

board = rrc.Board()
ctl = Controller(board)

def worker(servo_id, pulse):
    ctl.set_pwm_servo_pulse(servo_id, pulse, 1000)

# 创建线程
t1 = threading.Thread(target=worker, args=(1, 1700))
t2 = threading.Thread(target=AGC.runAction, args=("go_forward_one_step",))

t1.start()
t2.start()

t1.join()  # 等待 t1 执行完成
t2.join()
print("执行完成")
```

## 三、自问自答
### Q1: 线程是什么，多线程有什么作用？
**A1:**  
#### 线程（Thread）
是程序中的一个独立执行流程。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源。

#### 多线程的作用
1. **提高响应能力**：防止界面卡顿，例如后台处理数据时前台仍可操作
2. **提升计算效率**：利用多核CPU并行计算，如同时处理多个数据块
3. **优化资源利用**：比创建进程更轻量，适合高并发场景（如服务器处理请求）

#### 典型应用场景
- **浏览器**：多标签页同时加载和运行
- **游戏程序**：并行处理渲染、逻辑和网络通信
- **数据处理**：拆分大任务为多个子任务并行计算

#### 需要注意的问题
- **线程安全**：共享数据需通过锁机制保护
- **死锁风险**：多个线程相互等待资源可能导致程序停滞
- **调试难度**：并发问题较难复现和定位

---

### Q2: POST请求是什么？有什么作用？如何发送POST请求？
**A2:**  
#### 什么是 POST 请求

POST 是 HTTP 协议中的一种请求方法，主要用于向服务器提交数据。与 GET 请求不同，POST 请求将数据放在请求体中发送，而不是显示在 URL 中。

#### POST 请求的作用

1. 提交表单数据
2. 上传文件
3. 发送敏感信息（如密码）
4. 创建新资源（RESTful API 中）
5. 执行不幂等的操作（如支付）

#### 如何发送 POST 请求

##### 1. 使用 HTML 表单

```html

<form action="/submit" method="post">
  <input type="text" name="username">
  <input type="password" name="password">
  <button type="submit">提交</button>
</form>

```

##### 2. 使用 JavaScript (Fetch API)

```javascript
fetch('https://example.com/api', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    username: 'user123',
    password: 'pass456'
  })
})
.then(response => response.json())
.then(data => console.log(data));
```

##### 3. 使用 cURL 命令行工具

```bash
curl -X POST https://example.com/api \
  -H "Content-Type: application/json" \
  -d '{"username":"user123","password":"pass456"}'
```

##### 4. 使用 Python (requests 库)

```python
import requests

data = {'username': 'user123', 'password': 'pass456'}
response = requests.post('https://example.com/api', json=data)
print(response.json())
```

#### POST 请求的特点

1. 数据在请求体中传输，不在 URL 中显示
2. 没有长度限制（GET 有 URL 长度限制）
3. 可以被缓存，但通常不建议
4. 不应用于获取数据（应该用 GET）
5. 浏览器历史记录不会保存 POST 请求数据

---

### Q3: 类继承是什么？有什么作用？
**A3:**  
#### 类继承

类继承是面向对象编程中的一个核心概念，允许一个类（子类）基于另一个类（父类）来构建。子类会继承父类的属性和方法，并可以扩展或修改它们。

#### 作用
1. **代码复用**：避免重复编写相同的代码。
2. **层次化组织**：通过继承关系建立清晰的类层次结构。
3. **多态支持**：子类可以重写父类方法，实现不同行为。

#### 简单示例（Python）
```python
class Animal:  # 父类
    def speak(self):
        print("Animal sound")

class Dog(Animal):  # 子类继承Animal
    def speak(self):  # 重写父类方法
        print("Bark")

dog = Dog()
dog.speak()  # 输出: Bark
```

##### 关键点
- 子类自动获得父类的非私有成员
- 子类可添加新属性和方法
- 通过方法重写实现多态